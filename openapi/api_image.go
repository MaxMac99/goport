/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"

	"github.com/docker/docker/errdefs"
	"github.com/gin-gonic/gin"
	"gitlab.com/maxmac99/goport/impl"
	"gitlab.com/maxmac99/goport/models"
)

// BuildPrune - Delete builder cache
func BuildPruneHandler(c *gin.Context) {
	var opts models.BuildPruneOpts
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.BuildPrune(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// BuildCancel - Cancel Build
func BuildCancelHandler(c *gin.Context) {
	var opts models.BuildCancelOpts
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	err := impl.BuildCancel(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	c.JSON(204, gin.H{})
}

// ImageBuild - Build an image
func ImageBuildHandler(c *gin.Context) {
	var opts models.ImageBuildOpts
	if err := c.ShouldBindQuery(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	stream, err := impl.ImageBuild(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if stream == nil {
		c.JSON(200, gin.H{})
		return
	} else {
		c.Header("Content-Type", "application/json")
		c.Writer.Flush()
		c.Stream(stream)
		return
	}
}

// ImageCommit - Create a new image from a container
func ImageCommitHandler(c *gin.Context) {
	var opts models.ImageCommitOpts
	if err := c.ShouldBindQuery(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageCommit(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(201, response)
		return
	}
}

// ImageCreate - Create an image
func ImageCreateHandler(c *gin.Context) {
	var opts models.ImageCreateOpts
	if err := c.ShouldBindHeader(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	stream, err := impl.ImageCreate(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, models.ErrorResponse{
			Message: err.Error(),
		})
		return
	}
	if stream == nil {
		c.JSON(200, gin.H{})
		return
	} else {
		c.Header("Content-Type", "application/json")
		c.Writer.Flush()
		c.Stream(stream)
		return
	}
}

// ImageDelete - Remove an image
func ImageDeleteHandler(c *gin.Context) {
	var opts models.ImageDeleteOpts
	if err := c.ShouldBindUri(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageDelete(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImageHistory - Get the history of an image
func ImageHistoryHandler(c *gin.Context) {
	var opts models.ImageHistoryOpts
	if err := c.ShouldBindUri(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageHistory(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImageInspect - Inspect an image
func ImageInspectHandler(c *gin.Context) {
	var opts models.ImageInspectOpts
	if err := c.ShouldBindUri(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageInspect(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImageList - List Images
func ImageListHandler(c *gin.Context) {
	var opts models.ImageListOpts
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageList(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImageLoad - Import images
func ImageLoadHandler(c *gin.Context) {
	var opts models.ImageLoadOpts
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	stream, err := impl.ImageLoad(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, models.ErrorResponse{
			Message: err.Error(),
		})
		return
	}
	if stream == nil {
		c.JSON(200, gin.H{})
		return
	} else {
		c.Header("Content-Type", "application/json")
		c.Writer.Flush()
		c.Stream(stream)
		return
	}
}

// ImagePrune - Delete unused images
func ImagePruneHandler(c *gin.Context) {
	var opts models.ImagePruneOpts
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImagePrune(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImagePush - Push an image
func ImagePushHandler(c *gin.Context) {
	var opts models.ImagePushOpts
	if err := c.ShouldBindUri(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBindHeader(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	stream, err := impl.ImagePush(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, models.ErrorResponse{
			Message: err.Error(),
		})
		return
	}
	if stream == nil {
		c.JSON(200, gin.H{})
		return
	} else {
		c.Header("Content-Type", "application/json")
		c.Writer.Flush()
		c.Stream(stream)
		return
	}
}

// ImageSearch - Search images
func ImageSearchHandler(c *gin.Context) {
	var opts models.ImageSearchOpts
	if err := c.ShouldBindHeader(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	response, err := impl.ImageSearch(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	if response != nil {
		c.JSON(200, response)
		return
	}
}

// ImageTag - Tag an image
func ImageTagHandler(c *gin.Context) {
	var opts models.ImageTagOpts
	if err := c.ShouldBindUri(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	if err := c.ShouldBind(&opts); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{Message: err.Error()})
		return
	}
	err := impl.ImageTag(c, &opts)
	if err != nil {
		code := errdefs.GetHTTPErrorStatusCode(err)
		c.JSON(code, err.Error())
		return
	}
	c.JSON(201, gin.H{})
}
