/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"io"
	"strconv"
	"sync"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/client"
	"github.com/gin-gonic/gin"
	"gitlab.com/maxmac99/goport/context"
	"gitlab.com/maxmac99/goport/models"
)

// ContainerChanges - Get changes on a containerâ€™s filesystem
func ContainerChanges(c *gin.Context, opts *models.ContainerChangesOpts) (*[]models.ContainerChangeResponseItem, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	diff, err := client.ContainerDiff(c, opts.Id)
	if err != nil {
		return nil, err
	}
	response := make([]models.ContainerChangeResponseItem, 0)
	for _, item := range diff {
		response = append(response, models.ContainerChangeResponseItem{
			Path: item.Path,
			Kind: item.Kind,
		})
	}
	return &response, nil
}

// ContainerCreate - Create a container
func ContainerCreate(c *gin.Context, opts *models.ContainerCreateOpts) (*models.ContainerCreateResponse, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	config := models.MapConfigFromOptions(opts.ContainerCreateConfig)
	hostConfig := models.MapHostConfigFromOptions(opts.HostConfig)
	networkingConfig := models.MapNetworkingConfigFromOptions(opts.NetworkingConfig)
	create, err := client.ContainerCreate(c, &config, &hostConfig, &networkingConfig, nil, opts.Name)
	if err != nil {
		return nil, err
	}
	response := models.ContainerCreateResponse{
		Id:       create.ID,
		Warnings: create.Warnings,
	}
	return &response, nil
}

// ContainerDelete - Remove a container
func ContainerDelete(c *gin.Context, opts *models.ContainerDeleteOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	options := types.ContainerRemoveOptions{
		RemoveVolumes: opts.V,
		RemoveLinks:   opts.Link,
		Force:         opts.Force,
	}
	return client.ContainerRemove(c, opts.Id, options)
}

// ContainerExport - Export a container
func ContainerExport(c *gin.Context, opts *models.ContainerExportOpts) (func(w io.Writer) bool, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	reader, err := client.ContainerExport(c, opts.Id)
	if err != nil {
		return nil, err
	}
	return func(w io.Writer) bool {
		_, err := io.Copy(w, reader)
		return err != nil
	}, nil
}

// ContainerInspect - Inspect a container
func ContainerInspect(c *gin.Context, opts *models.ContainerInspectOpts) (*models.ContainerInspectResponse, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	inspect, err := client.ContainerInspect(c, opts.Id)
	response := models.MapToContainerInspectResponse(inspect)
	if err != nil {
		return nil, err
	}
	return &response, nil
}

// ContainerKill - Kill a container
func ContainerKill(c *gin.Context, opts *models.ContainerKillOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.ContainerKill(c, opts.Id, opts.Signal)
}

// ContainerList - List containers
func ContainerList(c *gin.Context, opts *models.ContainerListOpts) (*map[string][]models.ContainerSummary, error) {
	clients, err := context.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	options := types.ContainerListOptions{
		Quiet:   false,
		Size:    opts.Size,
		All:     opts.All,
		Latest:  false,
		Since:   "",
		Before:  "",
		Limit:   opts.Limit,
		Filters: parsedFilters,
	}

	output := make(map[string][]models.ContainerSummary, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			list, err := cli.ContainerList(c, options)
			if err != nil {
				wg.Done()
				return
			}
			var contextItems []models.ContainerSummary
			for _, item := range list {
				contextItems = append(contextItems, models.MapToContainerSummary(item))
			}
			mutex.Lock()
			output[context] = contextItems
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &output, nil
}

// ContainerLogs - Get container logs
func ContainerLogs(c *gin.Context, opts *models.ContainerLogsOpts) (func(w io.Writer) bool, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := types.ContainerLogsOptions{
		ShowStdout: opts.Stdout,
		ShowStderr: opts.Stderr,
		Since:      strconv.Itoa(opts.Since), // Unix to unix conversion
		Until:      strconv.Itoa(opts.Until),
		Timestamps: opts.Timestamps,
		Follow:     opts.Follow,
		Tail:       opts.Tail,
		Details:    false,
	}
	reader, err := client.ContainerLogs(c, opts.Id, options)
	if err != nil {
		return nil, err
	}
	return StreamReadingResponse(c, reader), nil
}

// ContainerPause - Pause a container
func ContainerPause(c *gin.Context, opts *models.ContainerPauseOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.ContainerPause(c, opts.Id)
}

// ContainerPrune - Delete stopped containers
func ContainerPrune(c *gin.Context, opts *models.ContainerPruneOpts) (*map[string]models.ContainerPruneResponseItem, error) {
	clients, err := context.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}

	response := make(map[string]models.ContainerPruneResponseItem, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			prune, err := cli.ContainersPrune(c, parsedFilters)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			response[context] = models.ContainerPruneResponseItem{
				ContainersDeleted: prune.ContainersDeleted,
				SpaceReclaimed:    prune.SpaceReclaimed,
			}
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &response, nil
}

// ContainerRename - Rename a container
func ContainerRename(c *gin.Context, opts *models.ContainerRenameOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.ContainerRename(c, opts.Id, opts.Name)
}

// ContainerResize - Resize a container TTY
func ContainerResize(c *gin.Context, opts *models.ContainerResizeOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	options := types.ResizeOptions{
		Height: opts.H,
		Width:  opts.W,
	}
	return client.ContainerResize(c, opts.Id, options)
}

// ContainerRestart - Restart a container
func ContainerRestart(c *gin.Context, opts *models.ContainerRestartOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	duration, err := time.ParseDuration(strconv.Itoa(opts.T))
	if err != nil {
		return err
	}
	return client.ContainerRestart(c, opts.Id, &duration)
}

// ContainerStart - Start a container
func ContainerStart(c *gin.Context, opts *models.ContainerStartOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	options := types.ContainerStartOptions{
		CheckpointID:  "",
		CheckpointDir: "",
	}
	return client.ContainerStart(c, opts.Id, options)
}

// ContainerStats - Get container stats based on resource usage
func ContainerStats(c *gin.Context, opts *models.ContainerStatsOpts) ([]byte, func(w io.Writer) bool, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, nil, err
	}

	var response types.ContainerStats
	if opts.OneShot {
		response, err = client.ContainerStatsOneShot(c, opts.Id)
	} else {
		response, err = client.ContainerStats(c, opts.Id, opts.Stream)
	}
	if err != nil {
		return nil, nil, err
	}
	if opts.OneShot || !opts.Stream {
		data, err := io.ReadAll(response.Body)
		if err != nil {
			return nil, nil, err
		}
		return data, nil, nil
	}
	return nil, StreamReadingResponse(c, response.Body), nil
}

// ContainerStop - Stop a container
func ContainerStop(c *gin.Context, opts *models.ContainerStopOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	duration, err := time.ParseDuration(strconv.Itoa(opts.T))
	if err != nil {
		return err
	}
	return client.ContainerStop(c, opts.Id, &duration)
}

// ContainerTop - List processes running inside a container
func ContainerTop(c *gin.Context, opts *models.ContainerTopOpts) (*models.ContainerTopResponse, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	args := []string{opts.PsArgs}
	response, err := client.ContainerTop(c, opts.Id, args)
	if err != nil {
		return nil, err
	}
	return &models.ContainerTopResponse{
		Titles:    response.Titles,
		Processes: response.Processes,
	}, nil
}

// ContainerUnpause - Unpause a container
func ContainerUnpause(c *gin.Context, opts *models.ContainerUnpauseOpts) error {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.ContainerUnpause(c, opts.Id)
}

// ContainerUpdate - Update a container
func ContainerUpdate(c *gin.Context, opts *models.ContainerUpdateOpts) (*models.ContainerUpdateResponse, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	config := models.MapContainerUpdateConfigFromOptions(*opts)
	response, err := client.ContainerUpdate(c, opts.Id, config)
	if err != nil {
		return nil, err
	}
	return &models.ContainerUpdateResponse{
		Warnings: response.Warnings,
	}, nil
}

// ContainerWait - Wait for a container
func ContainerWait(c *gin.Context, opts *models.ContainerWaitOpts) (*models.ContainerWaitResponse, error) {
	client, err := context.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	responseC, errC := client.ContainerWait(c, opts.Id, container.WaitCondition(opts.Condition))
	select {
	case response := <-responseC:
		var errorResponse *models.ContainerWaitResponseError = nil
		if response.Error != nil {
			errorResponse = &models.ContainerWaitResponseError{
				Message: response.Error.Message,
			}
		}
		return &models.ContainerWaitResponse{
			StatusCode: response.StatusCode,
			Error:      errorResponse,
		}, nil
	case err = <-errC:
		return nil, err
	}
}
