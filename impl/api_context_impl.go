/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"github.com/gin-gonic/gin"
	"github.com/maxmac99/goport/context"
	"github.com/maxmac99/goport/goport"
	"github.com/maxmac99/goport/models"
)

// ContextCreate - Create a context
func ContextCreate(c *gin.Context, opts *models.ContextCreateOpts) (*string, error) {
	server := goport.GetGoPort()
	err := context.CreateContext(server, &context.CreateOptions{
		Name:        opts.Name,
		Description: opts.Description,
		Docker:      opts.Docker,
		From:        opts.From,
	})
	if err != nil {
		return nil, err
	}
	return &opts.Name, nil
}

// ContextDelete - Remove a context
func ContextDelete(c *gin.Context, opts *models.ContextDeleteOpts) error {
	server := goport.GetGoPort()
	return context.RemoveContext(server, opts.Name, opts.Force)
}

// ContextInspect - Inspect a context
func ContextInspect(c *gin.Context, opts *models.ContextInspectOpts) (*models.ContextInspectResponse, error) {
	server := goport.GetGoPort()
	response, err := context.InspectContext(server, opts.Name)
	if err != nil {
		return nil, err
	}
	tlsMaterial := make(map[string][]string)
	for key, value := range response.TLSMaterial {
		tlsMaterial[key] = value
	}
	return &models.ContextInspectResponse{
		Name:        response.Name,
		Metadata:    response.Metadata,
		Endpoints:   response.Endpoints,
		TLSMaterial: tlsMaterial,
		Storage: models.ContextInspectResponseStorage{
			MetadataPath: response.Storage.MetadataPath,
			TLSPath:      response.Storage.TLSPath,
		},
	}, nil
}

// ContextList - List contexts
func ContextList(c *gin.Context) (*[]models.ContextSummary, error) {
	server := goport.GetGoPort()
	response, err := context.ListContext(server)
	if err != nil {
		return nil, err
	}
	var result []models.ContextSummary
	for _, item := range *response {
		var kubernetes *string
		if item.KubernetesEndpoint != "" {
			kubernetes = &item.KubernetesEndpoint
		}
		result = append(result, models.ContextSummary{
			Name:         item.Name,
			Description:  item.Description,
			Docker:       item.DockerEndpoint,
			Kubernetes:   kubernetes,
			Orchestrator: item.StackOrchestrator,
		})
	}
	return &result, nil
}

// ContextUpdate - Update a context
func ContextUpdate(c *gin.Context, opts *models.ContextUpdateOpts) error {
	server := goport.GetGoPort()
	return context.UpdateContext(server, &context.UpdateOptions{
		Name:        opts.Name,
		Description: opts.Description,
		Docker:      opts.Docker,
	})
}
