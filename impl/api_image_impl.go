/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"io"
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/client"
	"github.com/gin-gonic/gin"
	"gitlab.com/maxmac99/goport/controllers"
	"gitlab.com/maxmac99/goport/models"
)

// BuildPrune - Delete builder cache
func BuildPrune(c *gin.Context, opts *models.BuildPruneOpts) (*models.BuildPruneResponse, error) {
	clients, err := controllers.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	options := types.BuildCachePruneOptions{
		All:         opts.All,
		KeepStorage: opts.KeepStorage,
		Filters:     parsedFilters,
	}

	var cachesDeleted []string
	var reclaimedSpace uint64 = 0
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			prune, err := cli.BuildCachePrune(c, options)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			cachesDeleted = append(cachesDeleted, prune.CachesDeleted...)
			reclaimedSpace += prune.SpaceReclaimed
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &models.BuildPruneResponse{
		CachesDeleted:  cachesDeleted,
		SpaceReclaimed: reclaimedSpace,
	}, nil
}

// ImageBuild - Build an image
func ImageBuild(c *gin.Context, opts *models.ImageBuildOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := models.MapImageBuildFromOptions(*opts)
	response, err := client.ImageBuild(c, c.Request.Body, options)
	if err != nil {
		return nil, err
	}
	return controllers.StreamResponse(c, response.Body), nil
}

// ImageCommit - Create a new image from a container
func ImageCommit(c *gin.Context, opts *models.ImageCommitOpts) (*models.IdResponse, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := models.MapImageCommitFromOptions(*opts)
	response, err := client.ContainerCommit(c, opts.Container, options)
	if err != nil {
		return nil, err
	}
	return &models.IdResponse{
		Id: response.ID,
	}, nil
}

// ImageCreate - Create an image
func ImageCreate(c *gin.Context, opts *models.ImageCreateOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	var response io.ReadCloser
	if opts.FromImage != "" {
		all := false
		tag := ""
		if opts.Tag != nil {
			all = *opts.Tag == ""
			tag = *opts.Tag
		}
		options := types.ImagePullOptions{
			All:           all,
			RegistryAuth:  opts.RegistryAuth,
			PrivilegeFunc: nil,
			Platform:      opts.Platform,
		}
		response, err = client.ImagePull(c, opts.FromImage+":"+tag, options)
	} else {
		source := types.ImageImportSource{
			Source:     c.Request.Body,
			SourceName: opts.FromSrc,
		}
		tag := ""
		if opts.Tag != nil {
			tag = *opts.Tag
		}
		options := types.ImageImportOptions{
			Tag:      tag,
			Message:  opts.Message,
			Changes:  []string{},
			Platform: opts.Platform,
		}
		response, err = client.ImageImport(c, source, opts.Repo, options)
	}
	if err != nil {
		return nil, err
	}
	if opts.Quiet {
		return nil, nil
	}
	return controllers.StreamResponse(c, response), nil
}

// ImageDelete - Remove an image
func ImageDelete(c *gin.Context, opts *models.ImageDeleteOpts) (*[]models.ImageDeleteResponseItem, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := types.ImageRemoveOptions{
		Force:         opts.Force,
		PruneChildren: !opts.Noprune,
	}
	response, err := client.ImageRemove(c, opts.Name, options)
	if err != nil {
		return nil, err
	}
	var modelResponse []models.ImageDeleteResponseItem
	for _, item := range response {
		modelResponse = append(modelResponse, models.ImageDeleteResponseItem{
			Untagged: item.Untagged,
			Deleted:  item.Deleted,
		})
	}
	return &modelResponse, nil
}

// ImageHistory - Get the history of an image
func ImageHistory(c *gin.Context, opts *models.ImageHistoryOpts) (*[]models.HistoryResponseItem, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	response, err := client.ImageHistory(c, opts.Name)
	if err != nil {
		return nil, err
	}
	var modelResponse []models.HistoryResponseItem
	for _, item := range response {
		modelResponse = append(modelResponse, models.HistoryResponseItem{
			Id:        item.ID,
			Created:   item.Created,
			CreatedBy: item.CreatedBy,
			Tags:      item.Tags,
			Size:      item.Size,
			Comment:   item.Comment,
		})
	}
	return &modelResponse, nil
}

// ImageInspect - Inspect an image
func ImageInspect(c *gin.Context, opts *models.ImageInspectOpts) (*types.ImageInspect, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	response, _, err := client.ImageInspectWithRaw(c, opts.Name)
	if err != nil {
		return nil, err
	}
	return &response, nil
}

// ImageList - List Images
func ImageList(c *gin.Context, opts *models.ImageListOpts) (*map[string][]models.ImageSummary, error) {
	clients, err := controllers.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	options := types.ImageListOptions{
		All:     opts.All,
		Filters: parsedFilters,
	}
	output := make(map[string][]models.ImageSummary, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			list, err := cli.ImageList(c, options)
			if err != nil {
				wg.Done()
				return
			}
			var contextItems []models.ImageSummary
			for _, item := range list {
				contextItems = append(contextItems, models.MapToImageSummary(item))
			}
			mutex.Lock()
			output[context] = contextItems
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &output, nil
}

// ImageLoad - Import images
func ImageLoad(c *gin.Context, opts *models.ImageLoadOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	response, err := client.ImageLoad(c, c.Request.Body, opts.Quiet)
	if err != nil {
		return nil, err
	}
	return controllers.StreamResponse(c, response.Body), nil
}

// ImagePrune - Delete unused images
func ImagePrune(c *gin.Context, opts *models.ImagePruneOpts) (*models.ImagePruneResponse, error) {
	clients, err := controllers.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	var imagesDeleted []models.ImageDeleteResponseItem
	var spaceReclaimed uint64
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			response, err := cli.ImagesPrune(c, parsedFilters)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			for _, item := range response.ImagesDeleted {
				imagesDeleted = append(imagesDeleted, models.ImageDeleteResponseItem{
					Untagged: item.Untagged,
					Deleted:  item.Deleted,
				})
			}
			spaceReclaimed += response.SpaceReclaimed
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &models.ImagePruneResponse{
		ImagesDeleted:  imagesDeleted,
		SpaceReclaimed: spaceReclaimed,
	}, nil
}

// ImagePush - Push an image
func ImagePush(c *gin.Context, opts *models.ImagePushOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := types.ImagePushOptions{
		All:           false,
		RegistryAuth:  opts.RegistryAuth,
		PrivilegeFunc: func() (string, error) { panic("not implemented") },
		Platform:      "",
	}
	response, err := client.ImagePush(c, opts.Name+":"+opts.Tag, options)
	if err != nil {
		return nil, err
	}
	return controllers.StreamResponse(c, response), nil
}

// ImageSearch - Search images
func ImageSearch(c *gin.Context, opts *models.ImageSearchOpts) (*[]models.ImageSearchResponseItem, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	options := types.ImageSearchOptions{
		RegistryAuth:  opts.RegistryAuth,
		PrivilegeFunc: nil,
		Filters:       parsedFilters,
		Limit:         opts.Limit,
	}
	result, err := client.ImageSearch(c, opts.Term, options)
	if err != nil {
		return nil, err
	}
	var response []models.ImageSearchResponseItem
	for _, item := range result {
		response = append(response, models.ImageSearchResponseItem{
			Description: item.Description,
			IsOfficial:  item.IsOfficial,
			IsAutomated: item.IsAutomated,
			Name:        item.Name,
			StarCount:   item.StarCount,
		})
	}
	return &response, nil
}

// ImageTag - Tag an image
func ImageTag(c *gin.Context, opts *models.ImageTagOpts) error {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.ImageTag(c, opts.Name, opts.Repo+":"+opts.Tag)
}
