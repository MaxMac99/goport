/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"encoding/json"
	"io"
	"strconv"
	"sync"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/client"
	"github.com/gin-gonic/gin"
	"gitlab.com/maxmac99/goport/context"
	"gitlab.com/maxmac99/goport/goport"
	"gitlab.com/maxmac99/goport/models"
)

// SystemDataUsage - Get data usage information
func SystemDataUsage(c *gin.Context, opts *models.SystemDataUsageOpts) (*map[string]types.DiskUsage, error) {
	clients, err := context.ResolveContexts(opts.Context, client.WithTimeout(2*time.Second))
	if err != nil {
		return nil, err
	}
	output := make(map[string]types.DiskUsage, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			list, err := cli.DiskUsage(c)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			output[context] = list
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &output, nil
}

// SystemEvents - Monitor events
func SystemEvents(c *gin.Context, opts *models.SystemEventsOpts) (func(w io.Writer) bool, error) {
	clients, err := context.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	options := types.EventsOptions{
		Since:   opts.Since,
		Until:   opts.Until,
		Filters: parsedFilters,
	}
	output := make(chan map[string]models.SystemEventsResponse)
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			listC, errC := cli.Events(c, options)
			for {
				select {
				case list, ok := <-listC:
					if !ok {
						wg.Done()
						return
					}
					output <- map[string]models.SystemEventsResponse{
						context: {
							Message: list,
						},
					}
				case errI, ok := <-errC:
					if !ok {
						wg.Done()
						return
					}
					output <- map[string]models.SystemEventsResponse{
						context: {
							ErrorMessage: &models.ErrorResponse{
								Message: errI.Error(),
							},
						},
					}
				case <-c.Request.Context().Done():
					wg.Done()
					return
				}
			}
		}(context, cli)
	}
	go func() {
		wg.Wait()
		close(output)
	}()
	return func(w io.Writer) bool {
		item, ok := <-output
		if !ok {
			return false
		}
		response, err := json.Marshal(item)
		if err != nil {
			close(output)
			return false
		}
		response = append(response, '\n')
		w.Write(response)
		return true
	}, nil
}

// SystemInfo - Get system information
func SystemInfo(c *gin.Context, opts *models.SystemInfoOpts) (*map[string]types.Info, error) {
	clients, err := context.ResolveContexts(opts.Context, client.WithTimeout(2*time.Second))
	if err != nil {
		return nil, err
	}
	output := make(map[string]types.Info, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			list, err := cli.Info(c)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			output[context] = list
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &output, nil
}

// SystemPing - Ping
type SystemPingResponseItem struct {
	APIVersion     string `json:"ApiVersion,omitempty"`
	BuilderVersion string `json:"BuilderVersion,omitempty"`
	Experimental   bool   `json:"Experimental,omitempty"`
	OSType         string `json:"OSType,omitempty"`
	Error          string `json:"Error,omitempty"`
}

func SystemPing(c *gin.Context, opts *models.SystemPingOpts) (map[string]SystemPingResponseItem, error) {
	clients, err := context.ResolveContexts(opts.Context, client.WithTimeout(2*time.Second))
	if err != nil {
		return nil, err
	}

	output := make(map[string]SystemPingResponseItem, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			response, err := cli.Ping(c)
			if err != nil {
				mutex.Lock()
				output[context] = SystemPingResponseItem{
					Error: err.Error(),
				}
				mutex.Unlock()
				wg.Done()
				return
			}
			mutex.Lock()
			output[context] = SystemPingResponseItem{
				APIVersion:     response.APIVersion,
				BuilderVersion: string(response.BuilderVersion),
				Experimental:   response.Experimental,
				OSType:         response.OSType,
			}
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	c.Header("GoPort-Version", goport.Version)
	wg.Wait()
	return output, nil
}

// SystemPingHead - Ping
func SystemPingHead(c *gin.Context, opts *models.SystemPingHeadOpts) error {
	client, err := context.ResolveContext(opts.Context, client.WithTimeout(2*time.Second))
	if err != nil {
		return err
	}
	response, err := client.Ping(c)
	if err != nil {
		return err
	}
	c.Header("API-Version", response.APIVersion)
	c.Header("Builder-Version", string(response.BuilderVersion))
	c.Header("Docker-Experimental", strconv.FormatBool(response.Experimental))
	c.Header("OSType", response.OSType)
	c.Header("Goport-Version", goport.Version)
	return nil
}

// SystemVersion - Get version
func SystemVersion(c *gin.Context, opts *models.SystemVersionOpts) (*types.Version, error) {
	client, err := context.ResolveContext(opts.Context, client.WithTimeout(2*time.Second))
	if err != nil {
		return nil, err
	}
	response, err := client.ServerVersion(c)
	if err != nil {
		return nil, err
	}
	return &response, nil
}
