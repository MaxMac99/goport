/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"encoding/json"
	"io"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/compose-spec/compose-go/types"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"gitlab.com/maxmac99/compose/pkg/api"
	"gitlab.com/maxmac99/goport/controllers"
	"gitlab.com/maxmac99/goport/models"
	"gitlab.com/maxmac99/goport/project"
)

// ProjectBuild - Build the project
func ProjectBuild(c *gin.Context, opts *models.ProjectBuildOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil {
		return nil, err
	}
	progress := "plain"
	if opts.Quiet {
		progress = "quiet"
	}
	var args map[string]*string
	if opts.BuildArgs != "" {
		err = json.Unmarshal([]byte(opts.BuildArgs), &args)
		if err != nil {
			return nil, err
		}
	}
	reader, err := service.Build(project, api.BuildOptions{
		Pull:     opts.Pull,
		Progress: progress,
		Args:     args,
		NoCache:  opts.NoCache,
		Quiet:    opts.Quiet,
		Services: opts.Services,
	})
	if err != nil {
		return nil, err
	}
	if opts.Quiet {
		return nil, nil
	}

	return controllers.StreamResponse(c, reader), nil
}

// ProjectCreate - Create a project
func ProjectCreate(c *gin.Context, opts *models.ProjectCreateOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	err = project.AddProject(opts.Name, opts.Body, opts.Format)
	if err != nil {
		return err
	}
	p, err := project.GetProject(opts.Name)
	if err != nil {
		project.RemoveProject(opts.Name)
		return err
	}
	service := project.GetProjectService(client, c)
	_, err = service.Convert(p, api.ConvertOptions{
		Format: opts.Format,
		Output: "",
	})
	if err != nil {
		project.RemoveProject(opts.Name)
		return err
	}
	return nil
}

// ProjectDown - Stops containers and removes containers, networks, volumes, and images created by up
func ProjectDown(c *gin.Context, opts *models.ProjectDownOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	}
	if err == os.ErrNotExist {
		err = nil
	}
	var timeout *time.Duration
	if opts.Timeout != nil {
		*timeout, err = time.ParseDuration(strconv.FormatInt(*opts.Timeout, 10) + "s")
		if err != nil {
			return err
		}
	}
	downOptions := api.DownOptions{
		RemoveOrphans: opts.Removeorphans,
		Project:       project,
		Timeout:       timeout,
		Images:        opts.Rmi,
		Volumes:       opts.Volumes,
	}
	if err == nil {
		_, err = service.Down(project.Name, downOptions)
		return err
	}
	_, err = service.Down(opts.Name, downOptions)
	return err
}

// ProjectEvents - Stream container events for every container in the project
func ProjectEvents(c *gin.Context, opts *models.ProjectEventsOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	outputChan := make(chan api.Event)
	errorChan := make(chan error)
	var errorIn error
	eventsOptions := api.EventsOptions{
		Services: opts.Services,
		Consumer: func(e api.Event) error {
			select {
			case outputChan <- e:
				return errorIn
			case <-c.Request.Context().Done():
				return errors.Errorf("Client disconnected")
			}
		},
	}
	go func() {
		errorIn = service.Events(name, eventsOptions)
		errorChan <- errorIn
	}()
	time.Sleep(200 * time.Millisecond)
	if err != nil {
		return nil, err
	}
	return func(w io.Writer) bool {
		select {
		case e := <-outputChan:
			event := models.ProjectEvent{
				Timestamp:  e.Timestamp.UnixMilli(),
				Service:    e.Service,
				Container:  e.Container,
				Status:     e.Status,
				Attributes: e.Attributes,
			}
			output, errorIn := json.Marshal(event)
			if errorIn != nil {
				return false
			}
			output = append(output, '\n')
			w.Write(output)
			return true
		case err = <-errorChan:
			if err == nil {
				message := err.Error()
				w.Write([]byte(message))
			}
			return false
		case <-c.Request.Context().Done():
			errorIn = errors.Errorf("Client disconnected")
			return false
		}
	}, err
}

// ProjectImages - List images used by the created containers.
func ProjectImages(c *gin.Context, opts *models.ProjectImagesOpts) ([]models.ProjectImagesResponse, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	images, err := service.Images(name, api.ImagesOptions{
		Services: opts.Services,
	})
	if err != nil {
		return nil, err
	}
	var convImages []models.ProjectImagesResponse
	for _, image := range images {
		convImages = append(convImages, models.ProjectImagesResponse{
			ID:            image.ID,
			ContainerName: image.ContainerName,
			Repository:    image.Repository,
			Tag:           image.Tag,
			Size:          image.Size,
		})
	}
	return convImages, nil
}

// ProjectInspect - Inspect a project
func ProjectInspect(c *gin.Context, opts *models.ProjectInspectOpts) ([]byte, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	} else if err == os.ErrNotExist {
		err = nil
	}
	response, err := service.Convert(project, api.ConvertOptions{
		Format: opts.Format,
		Output: "",
	})
	return response, err
}

// ProjectKill - Forces running containers to stop by sending a SIGKILL signal.
func ProjectKill(c *gin.Context, opts *models.ProjectKillOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	} else if err == os.ErrNotExist {
		err = nil
	}
	_, err = service.Kill(project, api.KillOptions{
		Services: opts.Services,
		Signal:   opts.Signal,
	})
	return err
}

// ProjectList - List projects
func ProjectList(c *gin.Context) ([]project.Stack, error) {
	stacks, err := project.GetStacks()
	if err != nil {
		return nil, err
	}
	return stacks, nil
}

// ProjectLogs - Get project logs
func ProjectLogs(c *gin.Context, opts *models.ProjectLogsOpts) ([]map[string]interface{}, func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, nil, err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	if opts.Follow {
		response := ProjectLogsStream(c, name, service, opts)
		return nil, response, nil
	}
	response, err := ProjectLogsResponse(name, service, opts)
	return response, nil, err
}

func ProjectLogsStream(c *gin.Context, name string, service project.ProjectService, opts *models.ProjectLogsOpts) func(w io.Writer) bool {
	doneChan := make(chan bool)
	errChan := make(chan error)
	consumer := logConsumer{
		logChan:          make(chan log),
		statusChan:       make(chan status),
		registrationChan: make(chan registration),
	}
	go func() {
		err := service.Logs(name, &consumer, api.LogOptions{
			Services:   opts.Services,
			Tail:       opts.Tail,
			Since:      "",
			Until:      "",
			Follow:     opts.Follow,
			Timestamps: opts.Timestamps,
		})
		if err != nil {
			errChan <- err
		}
		doneChan <- true
	}()
	return func(w io.Writer) bool {
		select {
		case err := <-errChan:
			WriteError(err, w)
			return false
		case <-doneChan:
			return false
		case logItem := <-consumer.logChan:
			message := map[string]log{
				"log": logItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case statusItem := <-consumer.statusChan:
			message := map[string]status{
				"status": statusItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case registerItem := <-consumer.registrationChan:
			message := map[string]registration{
				"register": registerItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case <-c.Request.Context().Done():
			return false
		}
	}
}

func ProjectLogsResponse(name string, service project.ProjectService, opts *models.ProjectLogsOpts) ([]map[string]interface{}, error) {
	doneChan := make(chan bool)
	errChan := make(chan error)
	consumer := logConsumer{
		logChan:          make(chan log),
		statusChan:       make(chan status),
		registrationChan: make(chan registration),
	}
	go func() {
		err := service.Logs(name, &consumer, api.LogOptions{
			Services:   opts.Services,
			Tail:       opts.Tail,
			Since:      "",
			Until:      "",
			Follow:     opts.Follow,
			Timestamps: opts.Timestamps,
		})
		if err != nil {
			errChan <- err
		}
		doneChan <- true
	}()
	var allLogs []map[string]interface{}
	for {
		select {
		case err := <-errChan:
			return nil, err
		case <-doneChan:
			return allLogs, nil
		case logItem := <-consumer.logChan:
			message := map[string]interface{}{
				"log": logItem,
			}
			allLogs = append(allLogs, message)
		case statusItem := <-consumer.statusChan:
			message := map[string]interface{}{
				"status": statusItem,
			}
			allLogs = append(allLogs, message)
		case registerItem := <-consumer.registrationChan:
			message := map[string]interface{}{
				"register": registerItem,
			}
			allLogs = append(allLogs, message)
		}
	}
}

// ProjectPause - Pauses running containers of a service.
func ProjectPause(c *gin.Context, opts *models.ProjectPauseOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	_, err = service.Pause(name, api.PauseOptions{
		Services: opts.Services,
	})
	return err
}

// ProjectPs - Lists containers.
func ProjectPs(c *gin.Context, opts *models.ProjectPsOpts) (*[]models.ProjectContainerSummaryItem, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	psResponse, err := service.Ps(name, api.PsOptions{
		All:      opts.All,
		Services: opts.Services,
	})
	if err != nil {
		return nil, err
	}

	var response []models.ProjectContainerSummaryItem
	for _, item := range psResponse {
		var publishers []models.PortPublisher
		for _, publisher := range item.Publishers {
			publishers = append(publishers, models.PortPublisher{
				URL:           publisher.URL,
				TargetPort:    publisher.TargetPort,
				PublishedPort: publisher.PublishedPort,
				Protocol:      publisher.Protocol,
			})
		}
		response = append(response, models.ProjectContainerSummaryItem{
			Id:         item.ID,
			Name:       item.Name,
			Command:    item.Command,
			Project:    item.Project,
			Service:    item.Service,
			State:      item.State,
			Health:     item.Health,
			ExitCode:   item.ExitCode,
			Publishers: publishers,
		})
	}
	return &response, err
}

// ProjectPull - Pulls images associated with a service.
func ProjectPull(c *gin.Context, opts *models.ProjectPullOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	} else if err == os.ErrNotExist {
		err = nil
	}
	reader, err := service.Pull(project, api.PullOptions{
		Quiet:          opts.Quiet,
		IgnoreFailures: opts.Ignorepullfailures,
	})
	if err != nil {
		return nil, err
	}
	if opts.Quiet {
		return nil, nil
	}
	return controllers.StreamResponse(c, reader), nil
}

// ProjectPush - Pushes images for services to their respective `registry/repository`.
func ProjectPush(c *gin.Context, opts *models.ProjectPushOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	} else if err == os.ErrNotExist {
		err = nil
	}
	_, err = service.Push(project, api.PushOptions{
		IgnoreFailures: opts.IgnorePushFailures,
	})
	return err
}

// ProjectRemove - Removes stopped service containers.
func ProjectRemove(c *gin.Context, opts *models.ProjectRemoveOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	} else if err == os.ErrNotExist {
		err = nil
	}
	_, err = service.Remove(project, api.RemoveOptions{
		Volumes:  opts.Volumes,
		Force:    true,
		Services: opts.Services,
	})
	return err
}

// ProjectRestart - Restarts all stopped and running services.
func ProjectRestart(c *gin.Context, opts *models.ProjectRestartOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	} else if err == os.ErrNotExist {
		err = nil
	}
	var timeout *time.Duration
	if opts.Timeout != nil {
		*timeout, err = time.ParseDuration(strconv.FormatInt(*opts.Timeout, 10) + "s")
		if err != nil {
			return err
		}
	}
	_, err = service.Restart(project, api.RestartOptions{
		Timeout:  timeout,
		Services: opts.Services,
	})
	return err
}

// ProjectRun - Runs a one-time command against a service.
func ProjectRun(c *gin.Context, opts *models.ProjectRunOpts) (func(w io.Writer) bool, []map[string]interface{}, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, nil, err
	} else if err == os.ErrNotExist {
		err = nil
	}
	if opts.Detach {
		response, err := ProjectRunResponse(c, service, project, opts)
		return nil, response, err
	}
	return nil, nil, err
}

func ProjectRunResponse(c *gin.Context, service project.ProjectService, project *types.Project, opts *models.ProjectRunOpts) ([]map[string]interface{}, error) {
	outputChan := make(chan map[string]interface{})
	outBuffer := newStream("stdout", outputChan)
	errBuffer := newStream("stderr", outputChan)

	var output []map[string]interface{}
	go func() {
		for {
			select {
			case entry, ok := <-outputChan:
				if !ok {
					return
				}
				output = append(output, entry)
			case <-c.Request.Context().Done():
				return
			}
		}
	}()

	code, err := service.Run(project, api.RunOptions{
		Name:              opts.Body.Name,
		Service:           opts.Service,
		Command:           opts.Body.Command,
		Entrypoint:        opts.Body.Entrypoint,
		Detach:            opts.Detach,
		AutoRemove:        opts.AutoRemove,
		Stdin:             nil,
		Stdout:            outBuffer,
		Stderr:            errBuffer,
		Tty:               opts.Body.Tty,
		WorkingDir:        opts.Body.Workdir,
		User:              opts.Body.User,
		Environment:       opts.Body.Environment,
		Labels:            opts.Body.Labels,
		UseNetworkAliases: opts.Body.UseAliases,
		NoDeps:            !opts.Body.Deps,
		Index:             0,
	})
	close(outputChan)
	output = append(output, map[string]interface{}{
		"return": code,
	})
	return output, err
}

type runResponse struct {
	code int
	err  error
}

func ProjectRunStream(c *gin.Context, service project.ProjectService, project *types.Project, opts *models.ProjectRunOpts) func(w io.Writer) bool {
	outBuffer := newChannelBuffer()
	errBuffer := newChannelBuffer()
	returnChan := make(chan runResponse)

	go func() {
		code, err := service.Run(project, api.RunOptions{
			Name:              opts.Body.Name,
			Service:           opts.Service,
			Command:           opts.Body.Command,
			Entrypoint:        opts.Body.Entrypoint,
			Detach:            opts.Detach,
			AutoRemove:        opts.AutoRemove,
			Stdin:             nil,
			Stdout:            &outBuffer,
			Stderr:            &errBuffer,
			Tty:               opts.Body.Tty,
			WorkingDir:        opts.Body.Workdir,
			User:              opts.Body.User,
			Environment:       opts.Body.Environment,
			Labels:            opts.Body.Labels,
			UseNetworkAliases: opts.Body.UseAliases,
			NoDeps:            !opts.Body.Deps,
			Index:             0,
		})
		returnChan <- runResponse{
			code: code,
			err:  err,
		}
	}()

	return func(w io.Writer) bool {
		select {
		case output := <-outBuffer.out:
			message := map[string]interface{}{
				"stdout": string(output),
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case errorMessage := <-errBuffer.out:
			message := map[string]interface{}{
				"stderr": string(errorMessage),
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case returnMessage := <-returnChan:
			outBuffer.Close()
			errBuffer.Close()
			message := map[string]interface{}{
				"returnCode": returnMessage.code,
			}
			if returnMessage.err != nil {
				message["error"] = returnMessage.err.Error()
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return false
		case <-c.Request.Context().Done():
			outBuffer.Close()
			errBuffer.Close()
			return false
		}
	}
}

// ProjectStart - Starts existing containers for a service.
func ProjectStart(c *gin.Context, opts *models.ProjectStartOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	}

	if len(opts.Services) > 0 {
		err = project.ForServices(opts.Services)
		if err != nil {
			return err
		}
	}
	_, err = service.Start(project, api.StartOptions{})
	return err
}

// ProjectStop - Stops running containers without removing them.
func ProjectStop(c *gin.Context, opts *models.ProjectStopOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	}

	if len(opts.Services) > 0 {
		err = project.ForServices(opts.Services)
		if err != nil {
			return err
		}
	}
	var timeout *time.Duration
	if opts.Timeout != nil {
		*timeout, err = time.ParseDuration(strconv.FormatInt(*opts.Timeout, 10) + "s")
		if err != nil {
			return err
		}
	}
	_, err = service.Stop(project, api.StopOptions{
		Timeout:  timeout,
		Services: opts.Services,
	})
	return err
}

// ProjectTop - Displays the running processes.
func ProjectTop(c *gin.Context, opts *models.ProjectTopOpts) (*[]models.ProjectTopResponse, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	response, err := service.Top(name, opts.Services)
	if err != nil {
		return nil, err
	}
	var topResponse []models.ProjectTopResponse
	for _, item := range response {
		topResponse = append(topResponse, models.ProjectTopResponse{
			Id:        item.ID,
			Name:      item.Name,
			Titles:    item.Titles,
			Processes: item.Processes,
		})
	}
	return &topResponse, nil
}

// ProjectUnpause - Unpauses paused containers of a service.
func ProjectUnpause(c *gin.Context, opts *models.ProjectUnpauseOpts) error {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return err
	}
	name := opts.Name
	if err == nil {
		name = project.Name
	} else {
		err = nil
	}
	_, err = service.Unpause(name, api.PauseOptions{
		Services: opts.Services,
	})
	return err
}

// ProjectUp - Builds, (re)creates, starts, and attaches to containers for a service.
func ProjectUp(c *gin.Context, opts *models.ProjectUpOpts) (func(w io.Writer) bool, error) {
	client, err := controllers.ResolveContext("default")
	if err != nil {
		return nil, err
	}
	service := project.GetProjectService(client, c)
	project, err := project.GetProject(opts.Name)
	if err != nil && err != os.ErrNotExist {
		return nil, err
	}

	recreate := api.RecreateDiverged
	recreateDependencies := api.RecreateDiverged
	if opts.ForceRecreate {
		recreate = api.RecreateForce
	}
	if opts.AlwaysRecreateDeps {
		recreateDependencies = api.RecreateForce
	}
	if !opts.Recreate {
		recreate = api.RecreateNever
		recreateDependencies = api.RecreateNever
	}
	var timeout *time.Duration
	if opts.Timeout != nil {
		*timeout, err = time.ParseDuration(strconv.FormatInt(*opts.Timeout, 10) + "s")
		if err != nil {
			return nil, err
		}
	}
	upOpts := api.UpOptions{
		Create: api.CreateOptions{
			Services:             opts.Services,
			RemoveOrphans:        opts.RemoveOrphans,
			IgnoreOrphans:        strings.ToLower(project.Environment["COMPOSE_IGNORE_ORPHANS"]) == "true",
			Recreate:             recreate,
			RecreateDependencies: recreateDependencies,
			Inherit:              !opts.RenewAnonVolumes,
			Timeout:              timeout,
			QuietPull:            opts.QuietPull,
		},
		Start: api.StartOptions{
			Attach:       nil,
			AttachTo:     opts.Attach,
			CascadeStop:  opts.AbortOnContainerExit,
			ExitCodeFrom: opts.ExitCodeFrom,
		},
	}

	if opts.Detach {
		err = ProjectUpResponse(service, project, upOpts)
		return nil, err
	}
	return ProjectUpStream(c, service, project, upOpts), nil
}

func ProjectUpResponse(service project.ProjectService, project *types.Project, opts api.UpOptions) error {
	_, err := service.Up(project, opts)
	return err
}

func ProjectUpStream(c *gin.Context, service project.ProjectService, project *types.Project, opts api.UpOptions) func(w io.Writer) bool {
	doneChan := make(chan bool)
	errChan := make(chan error)
	consumer := logConsumer{
		logChan:          make(chan log),
		statusChan:       make(chan status),
		registrationChan: make(chan registration),
	}
	opts.Start.Attach = &consumer
	go func() {
		_, err := service.Up(project, opts)
		if err != nil {
			errChan <- err
		}
		doneChan <- true
	}()
	return func(w io.Writer) bool {
		select {
		case err := <-errChan:
			WriteError(err, w)
			return false
		case <-doneChan:
			return false
		case logItem := <-consumer.logChan:
			message := map[string]log{
				"log": logItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case statusItem := <-consumer.statusChan:
			message := map[string]status{
				"status": statusItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case registerItem := <-consumer.registrationChan:
			message := map[string]registration{
				"register": registerItem,
			}
			b, err := json.Marshal(message)
			if err != nil {
				WriteError(err, w)
			} else {
				w.Write(b)
			}
			return true
		case <-c.Request.Context().Done():
			return false
		}
	}
}
