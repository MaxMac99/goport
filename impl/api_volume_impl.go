/*
 * GoPort API
 *
 * The GoPort API extends the Docker Engine API to connect to remote Hosts by serving a context endpoint. It also adds the ability to manage docker-compose projects.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package impl

import (
	"sync"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/volume"
	"github.com/docker/docker/client"
	"github.com/gin-gonic/gin"
	"gitlab.com/maxmac99/goport/controllers"
	"gitlab.com/maxmac99/goport/models"
)

// VolumeCreate - Create a volume
func VolumeCreate(c *gin.Context, opts *models.VolumeCreateOpts) (*types.Volume, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	options := volume.VolumeCreateBody{
		Driver:     opts.Driver,
		DriverOpts: opts.DriverOpts,
		Labels:     opts.Labels,
		Name:       opts.Name,
	}
	response, err := client.VolumeCreate(c, options)
	if err != nil {
		return nil, err
	}
	return &response, nil
}

// VolumeDelete - Remove a volume
func VolumeDelete(c *gin.Context, opts *models.VolumeDeleteOpts) error {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return err
	}
	return client.VolumeRemove(c, opts.Name, opts.Force)
}

// VolumeInspect - Inspect a volume
func VolumeInspect(c *gin.Context, opts *models.VolumeInspectOpts) (*types.Volume, error) {
	client, err := controllers.ResolveContext(opts.Context)
	if err != nil {
		return nil, err
	}
	response, err := client.VolumeInspect(c, opts.Name)
	if err != nil {
		return nil, err
	}
	return &response, nil
}

// VolumeList - List volumes
func VolumeList(c *gin.Context, opts *models.VolumeListOpts) (*map[string]volume.VolumeListOKBody, error) {
	clients, err := controllers.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	output := make(map[string]volume.VolumeListOKBody, len(clients))
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			list, err := cli.VolumeList(c, parsedFilters)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			output[context] = list
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &output, nil
}

// VolumePrune - Delete unused volumes
func VolumePrune(c *gin.Context, opts *models.VolumePruneOpts) (*models.VolumePruneResponse, error) {
	clients, err := controllers.ResolveContexts(opts.Context)
	if err != nil {
		return nil, err
	}
	parsedFilters, err := filters.FromJSON(opts.Filters)
	if err != nil {
		return nil, err
	}
	var volumesDeleted []string
	var spaceReclaimed uint64
	var mutex sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(len(clients))
	for context, cli := range clients {
		go func(context string, cli client.APIClient) {
			response, err := cli.VolumesPrune(c, parsedFilters)
			if err != nil {
				wg.Done()
				return
			}
			mutex.Lock()
			volumesDeleted = append(volumesDeleted, response.VolumesDeleted...)
			spaceReclaimed += response.SpaceReclaimed
			mutex.Unlock()
			wg.Done()
		}(context, cli)
	}
	wg.Wait()
	return &models.VolumePruneResponse{
		VolumesDeleted: volumesDeleted,
		SpaceReclaimed: spaceReclaimed,
	}, nil
}
